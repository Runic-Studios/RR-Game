package com.runicrealms.game.items.command

import com.google.inject.Inject
import com.runicrealms.game.common.util.colorFormat
import com.runicrealms.game.items.config.item.GameItemTemplate
import com.runicrealms.game.items.generator.ItemStackConverter
import org.bukkit.Material
import org.bukkit.command.CommandSender
import org.bukkit.inventory.Inventory
import org.bukkit.inventory.ItemStack

class InventoryHelper @Inject constructor(val converter: ItemStackConverter) {

    /**
     * A method used to clear an inventory of all items that match the provided template
     *
     * @param inventory the inventory to wipe
     * @param amount the amount to remove
     * @param template the template
     * @param sender the user who initiated the clear inventory
     * @param ignoreItemStacks if an invalid item is found, if the wipe should be stopped
     */
    fun clearInventory(
        inventory: Inventory,
        amount: Int,
        template: GameItemTemplate?,
        sender: CommandSender?,
        ignoreItemStacks: Boolean,
    ) {
        var amountRemoved = 0
        val contents = inventory.contents
        for (i in contents.indices) {
            if (contents[i] != null && contents[i]!!.type != Material.AIR) {
                if (amount == -1 || amountRemoved < amount) {
                    val item = converter.convertToGameItem(contents[i] ?: continue)
                    if (item == null) {
                        if (ignoreItemStacks) {
                            continue
                        }
                        sender?.sendMessage("&dError removing items!".colorFormat())
                        return
                    }
                    var removeItem = false
                    if (template == null) {
                        removeItem = true
                    } else if (item.template == template) {
                        removeItem = true
                    }
                    if (removeItem) {
                        if (contents[i]!!.amount <= amount - amountRemoved || amount == -1) {
                            amountRemoved += contents[i]!!.amount
                            inventory.setItem(i, ItemStack(Material.AIR))
                        } else {
                            amountRemoved += amount - amountRemoved
                            inventory.getItem(i)!!.amount -= (amount - amountRemoved)
                        }
                    }
                }
            }
        }
    }

    /**
     * A method used to clear an inventory of all items that match the provided template
     *
     * @param inventory the inventory to wipe
     * @param amount the amount to remove
     * @param template the template
     * @param sender the user who initiated the clear inventory
     */
    fun clearInventory(
        inventory: Inventory,
        amount: Int,
        template: GameItemTemplate?,
        sender: CommandSender?,
    ) {
        clearInventory(inventory, amount, template, sender, false)
    }

    /**
     * A method used to wipe all copies of a given item template from an inventory
     *
     * @param inventory the inventory to wipe
     * @param template the template
     * @param sender the user who initiated the clear inventory
     * @param ignoreItemStacks if an invalid item is found, if the wipe should be stopped
     */
    fun clearInventory(
        inventory: Inventory,
        template: GameItemTemplate?,
        sender: CommandSender?,
        ignoreItemStacks: Boolean,
    ) {
        clearInventory(inventory, -1, template, sender, ignoreItemStacks)
    }

    /**
     * A method used to wipe all copies of a given item template from an inventory
     *
     * @param inventory the inventory to wipe
     * @param template the template
     * @param sender the user who initiated the clear inventory
     */
    fun clearInventory(inventory: Inventory, template: GameItemTemplate?, sender: CommandSender?) {
        clearInventory(inventory, -1, template, sender, false)
    }

    //    /**
    //     * Adds an ItemStack generated by a RunicItem into an inventory,
    //     * **while stacking the item with other stacks properly.**
    //     * WARNING: only works on ItemStacks generated from runic items!
    //     *
    //     * @param inventory   Inventory to add to
    //     * @param itemStack   ItemStack to add
    //     * @param assignNewId Should we assign a new dupe ID to the item
    //     * @return list of overflow items
    //     */
    //    fun addItem(inventory: Inventory, itemStack: ItemStack?, assignNewId: Boolean):
    // HashMap<Int, ItemStack>? {
    //        // Exit if item is null/air
    //
    //        if (itemStack == null || itemStack.type == Material.AIR) return null
    //
    //        // While iterating over inventory, keep track of how many of this item we have left to
    // add
    //        var amountLeft = itemStack.amount
    //        // Contents of this inventory
    //        val contents = inventory.contents
    //        // List of inventory slots that are being updated, need to receive new IDs
    //        val slotsReceivingNewIds: MutableList<Int> = LinkedList()
    //
    //        // Loop over contents
    //        for (i in contents.indices) {
    //            val item = contents[i]
    //
    //            if (amountLeft > 0) {
    //                // Exit if slot empty/we can't stack
    //
    //                if (item == null || item.type == Material.AIR) continue
    //                if (item.amount == item.maxStackSize) continue
    //
    //                // Check if the iterated item and our item have the same template
    //                if (NBTUtil.isNBTSimilar(itemStack, item, false, false)) {
    //                    // Clone item
    //
    //                    val itemToAdd = item.clone()
    //
    //                    // Depending on whether we can fit the rest of our items into the stack or
    // not...
    //                    if (item.amount + amountLeft <= item.maxStackSize) {
    //                        // If we can fit the entire amount into this stack, exit
    //                        itemToAdd.amount = amountLeft
    //                        amountLeft = 0
    //                    } else if (item.amount + amountLeft > item.maxStackSize) {
    //                        // If we can't fit (we have overflow), continue
    //                        val amountAdded = item.maxStackSize - item.amount
    //                        itemToAdd.amount = amountAdded
    //                        amountLeft -= amountAdded
    //                    }
    //
    //                    // This item has been updated, add to list of slots receiving new item IDs
    //                    slotsReceivingNewIds.add(i)
    //
    //                    // Add item
    //                    inventory.addItem(itemToAdd)
    //                }
    //            } else break
    //        }
    //
    //        // reassign some IDs for anti dupe
    //        for (slot in slotsReceivingNewIds) {
    //            val item: ItemStack = inventory.getItem(slot)
    //            if (item != null && item.type != Material.AIR) {
    //                DupeManager.assignNewDupeId(item)
    //            }
    //        }
    //
    //        // if we still have items unstacked, add normally to inventory
    //        if (amountLeft > 0) {
    //            itemStack.amount = amountLeft
    //            return inventory.addItem(itemStack)
    //        }
    //
    //        return HashMap() // return an empty hashmap
    //    }
    //
    //    /**
    //     * Adds an ItemStack generated by a RunicItem into an inventory,
    //     * **while stacking the item with other stacks properly.**
    //     * WARNING: only works on ItemStacks generated from runic items!
    //     *
    //     *
    //     * This method will drop overflow items on the ground (at location)!
    //     *
    //     * @param inventory   Inventory to add to
    //     * @param itemStack   ItemStack to add
    //     * @param location    the location to drop the items
    //     * @param assignNewId Should we assign a new dupe ID to the item
    //     */
    //    fun addItem(inventory: Inventory, itemStack: ItemStack?, location: Location, assignNewId:
    // Boolean) {
    //        addItem(
    //            inventory,
    //            itemStack,
    //            assignNewId
    //        ).forEach { (slot: Int?, leftOver: ItemStack?) ->
    //            Objects.requireNonNull(location.getWorld()).dropItem(location, leftOver)
    //        }
    //    }
    //
    //
    //    /**
    //     * Adds an ItemStack generated by a RunicItem into an inventory,
    //     * **while stacking the item with other stacks properly.**
    //     * WARNING: only works on ItemStacks generated from runic items!
    //     *
    //     * @param inventory Inventory to add to
    //     * @param itemStack ItemStack to add
    //     * @return list of overflow items
    //     */
    //    fun addItem(inventory: Inventory, itemStack: ItemStack?): HashMap<Int, ItemStack> {
    //        return addItem(inventory, itemStack, false)
    //    }
    //
    //    /**
    //     * Adds an ItemStack generated by a RunicItem into an inventory,
    //     * **while stacking the item with other stacks properly.**
    //     * WARNING: only works on ItemStacks generated from runic items!
    //     *
    //     *
    //     * This method will also drop overflow items on the ground (at location)!
    //     *
    //     * @param inventory Inventory to add to
    //     * @param itemStack ItemStack to add
    //     * @param location  the location to drop the items
    //     */
    //    fun addItem(inventory: Inventory, itemStack: ItemStack?, location: Location) {
    //        addItem(inventory, itemStack, false).forEach { (slot: Int?, leftOver: ItemStack?) ->
    //            Objects.requireNonNull(
    //                location.getWorld()
    //            ).dropItem(location, leftOver)
    //        }
    //    }
    //
    //    private fun isSimilar(itemStack: )

}
